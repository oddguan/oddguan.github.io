{"componentChunkName":"component---src-templates-blog-post-js","path":"/leetcode146/","result":{"data":{"site":{"siteMetadata":{"title":"Chenxiao's Blog","author":"Chenxiao Guan"}},"markdownRemark":{"id":"7df51e3b-6b6c-53d7-98b6-c25464666835","excerpt":"我们先来看一下题目描述：  学过计算机系统的同学应该都对LRU Cache不陌生，其实他就是一种数据结构来用有限的空间存储最近被使用的key value pairs，并达到constant time的get和put。 假设我们LRU Cache的capacity为2，那么我们最多只能存两个pairs…","html":"<p>我们先来看一下题目描述：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 510px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ee8b7141f80f9d64ca8038a09c572967/0abdd/%E6%8F%8F%E8%BF%B0.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 126.35135135135134%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAAAsSAAALEgHS3X78AAADPUlEQVQ4y51V6ZqbMBDj/V+w94Zw35e5DGGn0gDpbpr0R/N9jo2xZY2sGZx+GCSIQonCUJIkkSAIZOh74e/9/V1e/c537D82x/ajVFEieVFImmXaeIhdFtm2TftptnK73WRZVx2vGD+CnT9HJivSW9kwOWMzXy3rTYZx0oXjNIvBAQSZrZWuHxT4CeWdIUHa3iircZrEmB5go8zzLAPm2E+YZyOQXXaWbLNd9MAB726IhqBOZ4y4fiBRnIh79cT1fPl1ccUPQm18dj1Prr4vfhRLnOaSlbWkRSlRmklRt9IjGsqjITOUCScxHIPL6NHartMxmTZtC9ZG+6qupcM7ymGOdcoOGKeOjoEmYZxKkpe66QpGcZIqO7IOwgguiHBppZRVJUW5r+OYjeMETM3hDITcS4CNWVlJxjCSDAtrBSQQASPYqWla1ZkbqTP1psZkaRHh/ZYbTFy8QNK8ANNEwclG2QHQg74xAFVHsE/SVN5cV58v0Pzr9x96aJbnKpfD0zjBUEJlFN7ZhXF8D/2UgSzVk3DHils/e94B5xWQi6mHxeSjYbeP4+115txDrqHNl2/f5efbRRJkSQX9CJ5BAt4qW4wwOU8dGVqa5fDl/Dz1RliDCwgywcQUexd8PAw965gG380+qp1uH9LvE0MamxqR0f/+PjGkRkXVqPPLutHbrhAax7QSsyFBBHXbSQu9aa0Yz1zTdEazZGY6wjqsAc6KvwKbCcoFuhFmb80gNZ5LbKyaTouCQbic4zPBOzz3kIRgI3Kbea6pRxbB4UGCk4UuwGHLbdN2smDPjexZHKajfQL04MO3qw+D+wBNNdyBZQvhkHXV7gzPjY/tCWCsYK6Pqp3tGnIBw+Vh1yDSSsPn6YHVU4ZcTECmIMOmjlxAZiEzBAee5SqHH3kpbNOrkHfAQOsiFxZHyAT0o11bViQCNl2vTMsjihcaxtDQU5YEH46bIyDBrshhWoi3SzlyFFi2vxgipx16x7uHvAPSWxpycwJGqJfF/aD5uOXHy1GGNLbawFr9wtGXK2xC5uyXdbcH12xHsSCJRdf9aXzmd8Vh+WEdm44PFCswqw7TiPP8RlvkMOeY7ywW8o/v9W9OyYOEn9UHSAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"描述\"\n        title=\"描述\"\n        src=\"/static/ee8b7141f80f9d64ca8038a09c572967/0abdd/%E6%8F%8F%E8%BF%B0.png\"\n        srcset=\"/static/ee8b7141f80f9d64ca8038a09c572967/12f09/%E6%8F%8F%E8%BF%B0.png 148w,\n/static/ee8b7141f80f9d64ca8038a09c572967/e4a3f/%E6%8F%8F%E8%BF%B0.png 295w,\n/static/ee8b7141f80f9d64ca8038a09c572967/0abdd/%E6%8F%8F%E8%BF%B0.png 510w\"\n        sizes=\"(max-width: 510px) 100vw, 510px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>学过计算机系统的同学应该都对LRU Cache不陌生，其实他就是一种数据结构来用有限的空间存储最近被使用的key value pairs，并达到constant time的get和put。</p>\n<p>假设我们LRU Cache的capacity为2，那么我们最多只能存两个pairs。如果尝试存入第三个pair，那么第一个存入的pair就会被删除。所以我们在加入第三个pair之后\n如果再尝试get第一个key的话， 应该return -1。</p>\n<p>这道题的最终目标是为了让我们达到<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>的get和put。</p>\n<p>我个人认为这道题的难点在于设计，其次是实现。如果脑海中有了如何设计的大概思路，再加上熟悉使用的语言的基本包的话，其实写起来不是特别的难。而我在做这道题的时候，\n两者都不具备。。。想不出来怎么设计，也不知道C++中如何更好地实现这个数据结构。说多了都是泪。</p>\n<p>废话不多说，那么我们这道题的思路是什么？首先我们想要达到key value pairs的constant time get，马上想到的就是我们需要一个hash table来存储这个key value pairs。\n但是仅仅有一个hash table显然是不够的（如果够了的话这道题也不用考了。。），我们还需要一个数据结构来存储我们最近用过和最少用的pairs都是哪些。如果达到了我们的capacity\n上限，那我们就需要有一个方式来删除我们最不常用的那个pair。听上去是不是很像一个队列呢？没错，其实这个functionality我们就可以用一个queue来实现。在我们get一个key的时候，\n我们需要把这个key value pair放到我们的queue最后边来代表我们刚刚使用过这个queue；在我们capacity超出上限需要删除时，我们只需要把queue的头删除即可。虽然概念是一个queue，\n但其实实现起来为了达到<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>的时间复杂度的话，我们在向队列头插入时想要达到constant time，就要使用一个链表来达成。有了思路以后，我们来一步一步的完成这个数据结构。</p>\n<ol>\n<li>我们先来看一下我们LRU Cache的成员变量都有什么：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">LRUCache</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">;</span>\n    list<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">>></span> cache<span class=\"token punctuation\">;</span>\n    unordered_map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> list<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">>></span><span class=\"token operator\">::</span>iterator<span class=\"token operator\">></span> m<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>我们需要一个<code class=\"language-text\">capacity</code>成员变量来存储我们LRUCache的大小，一个双向链表来存储我们的key values pairs，以及一个hash table存储key到链表node的mapping。</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token keyword\">auto</span> it <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>m<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* trying to see if the pair is in the cache */</span>\n    \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>it <span class=\"token operator\">==</span> <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>m<span class=\"token punctuation\">.</span><span class=\"token function\">cend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* key is not in the cache */</span>\n    <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>cache<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token operator\">-></span>cache<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>cache<span class=\"token punctuation\">,</span> it<span class=\"token operator\">-></span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> it<span class=\"token operator\">-></span>second<span class=\"token operator\">-></span>second<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>接下来我们来看一下怎么实现get。整体来说思路比较简单，我们先check这个key是否在我们的cache中。如果不在的话我们直接return -1即可。反之，我们先把这个node\n放到我们cache的最前端，然后再return这个node的value即可。</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token keyword\">auto</span> it <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>m<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* whether it has the key or not */</span>\n    \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>it <span class=\"token operator\">!=</span> <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>m<span class=\"token punctuation\">.</span><span class=\"token function\">cend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        it<span class=\"token operator\">-></span>second<span class=\"token operator\">-></span>second <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token operator\">-></span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token operator\">-></span>cache<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>capacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> <span class=\"token keyword\">auto</span><span class=\"token operator\">&amp;</span> node <span class=\"token operator\">=</span> cache<span class=\"token punctuation\">.</span><span class=\"token function\">back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>m<span class=\"token punctuation\">.</span><span class=\"token function\">erase</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>cache<span class=\"token punctuation\">.</span><span class=\"token function\">pop_back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>cache<span class=\"token punctuation\">.</span><span class=\"token function\">emplace_front</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    m<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>cache<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>put在实现起来稍微复杂一点点，因为需要考虑一两个edge cases。首先第一步和get一样，我们先要确定放入的key是否已经存在于cache当中。如果存在的话，我们需要update旧的\nvalue pairs，然后将之放到我们cache的最前端。这一步的逻辑和get是一样的。</p>\n<p>其次，如果我们没有找到key，那么就说明给定的是一个新的key value pair。我们需要做的是先check目前cache的长度是否已经和capacity相等。如果是，那么我们需要先删除\ncache最后的node，然后再把新的node加到cache的最前端即可。最终，不要忘记把hash table的key map到cache的头部。</p>\n<h3>总结</h3>\n<p>其实对于我来说，这道题最难的地方还是在C++中的实现。。尤其是为什么我们要把双向链表初始化为a list of pair of ints，而不是单纯的list of ints。这样做的目的是因为，\n我们在put时需要达到<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>的时间复杂度，那么我们在删除最后的key value pairs是也需要达到<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。如果我们只存储value，在对hash table做删除操作时就不能达到<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>了。这个一开始对于我来说还是挺难理解的。</p>","frontmatter":{"title":"LeetCode 146: LRU Cache","date":"April 24, 2019","description":"经典面试题目LRU Cache，前一阵子面试挂了这道题，现在重新用C++做一遍感受一下。"}}},"pageContext":{"slug":"/leetcode146/","previous":{"fields":{"slug":"/leetcode31/"},"frontmatter":{"title":"LeetCode 31: Next Permutation"}},"next":{"fields":{"slug":"/leetcode33/"},"frontmatter":{"title":"LeetCode 33 & 153: Search in Rotated Sorted Array / Find Minimum in Rotated Sorted Array"}}}}}