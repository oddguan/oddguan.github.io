{"componentChunkName":"component---src-templates-blog-post-js","path":"/leetcode98/","result":{"data":{"site":{"siteMetadata":{"title":"Chenxiao's Blog","author":"Chenxiao Guan"}},"markdownRemark":{"id":"81b57cd8-8b66-5b57-8cc1-5732534114e7","excerpt":"怠惰了一整个暑假。。这几天要赶秋招了，赶紧开始紧密的刷题，不能再落下了。一个暑假过去感觉自己之前刷的题全部忘光了，所以先从相对简单的题目做起。 题目描述如下：\n 这道题目乍一看相当简单，仿佛只需要确认left和right child都是validBST，再确认左右child都分别小于大于当前node的val…","html":"<p>怠惰了一整个暑假。。这几天要赶秋招了，赶紧开始紧密的刷题，不能再落下了。一个暑假过去感觉自己之前刷的题全部忘光了，所以先从相对简单的题目做起。</p>\n<p>题目描述如下：\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 517px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/bd1b001a83eaf9c31e349bb871e1d09a/fa2f5/%E6%8F%8F%E8%BF%B0.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.02702702702703%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABaElEQVQoz21Si5KDIAz0/7+yp9erVRDxgRWwe9mo7XXmnNlJhGTZDRTZN4imRFof8NOCYQp4xAQ3TBjDimVN8OOkiClhmoPmOW/g93w+8fcrkCMQF9nZkKQh5aRFzLctSy7rOQtB1vWoNfmDiPmJwg8jeoGxHTrXww+DRHf8OwzjCNf3uDctmrZF1zlY2WuNRd00sF0nB7/VFqM0WCnSQtns/aDFJNn/PWKMn6DKlDWn8g/LcwjazMYTxlr0vVdCqmYjVeTDOnGOgXvrukrcR1WQlQu3+q4WCCdktErLPECtut0B1ZvDMlFdrwqKeBE+hLCsvhWtMaDqEBbM86yYDizLopH7s9w280Hmz7nTEYUVZA1SeP254UsIL2WleZAmqvMyU46EGKcJzu05iaj6Vteo74065AFKyORSlkpUfV+1gEpprWmNkuw3b9U24z4Cp5H9r0s53w+Hvh1xH3ba3+Vxo+/8f5w8v4uPBFEsXvWiAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"描述\"\n        title=\"描述\"\n        src=\"/static/bd1b001a83eaf9c31e349bb871e1d09a/fa2f5/%E6%8F%8F%E8%BF%B0.png\"\n        srcset=\"/static/bd1b001a83eaf9c31e349bb871e1d09a/12f09/%E6%8F%8F%E8%BF%B0.png 148w,\n/static/bd1b001a83eaf9c31e349bb871e1d09a/e4a3f/%E6%8F%8F%E8%BF%B0.png 295w,\n/static/bd1b001a83eaf9c31e349bb871e1d09a/fa2f5/%E6%8F%8F%E8%BF%B0.png 517w\"\n        sizes=\"(max-width: 517px) 100vw, 517px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>这道题目乍一看相当简单，仿佛只需要确认left和right child都是validBST，再确认左右child都分别小于大于当前node的val就可以了。但是这个方法有一个问题：假设我们有如下的BST，</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> 5\n|  \\\n2    7\n| \\  | \\\n1  3 4  9</code></pre></div>\n<p>我们的算法在得到这个tree时是会返回true的，但是这并不是一个valid的bst。我们可以看到在右侧的4是小于root 5的，所以应该严格的在这个bst的左子树上，但是右子树自己是一个valid BST。所以我们上面所描述的算法不成立。</p>\n<h3>Key Takeaway</h3>\n<p>我们可以换一个思路来想这个问题：</p>\n<blockquote>\n<p>BST有什么特性呢？如果我们有一个合法的bst，那在对它进行in-order traversal时，我们会得到一个完全排好升序的数组。如果在想到这个的前提下做这道题就会变得容易很多。</p>\n</blockquote>\n<h3>思路</h3>\n<p>想要check一个BST是否valid，我们可以对它进行in-order-traversal。如果我们traverse到一个node，它的val小于或等于traverse的前一个node val时，那它就不是一个valid bst。有了思路以后我们来看一下代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">isValidBST</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        TreeNode<span class=\"token operator\">*</span> prev <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">inOrderTraversal</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> prev<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">inOrderTraversal</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> node<span class=\"token punctuation\">,</span> TreeNode<span class=\"token operator\">*</span> <span class=\"token operator\">&amp;</span>prev<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>node<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">inOrderTraversal</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">-></span>left<span class=\"token punctuation\">,</span> prev<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prev <span class=\"token operator\">&amp;&amp;</span> prev<span class=\"token operator\">-></span>val <span class=\"token operator\">>=</span> node<span class=\"token operator\">-></span>val<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        \n        prev <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">inOrderTraversal</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">-></span>right<span class=\"token punctuation\">,</span> prev<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>写一个<code class=\"language-text\">inOrderTravesal</code>的helper method来帮助我们遍历bst。除此之外，我们需要一个<code class=\"language-text\">prev</code>指针来保存当前node的前一个node。遍历过程中，我们只需要保持in-order的顺序，并一直比较<code class=\"language-text\">prev</code>和<code class=\"language-text\">node</code>的val，且遍历完一个node之后update一下<code class=\"language-text\">prev</code>为当前node即可。</p>","frontmatter":{"title":"Leetcode 98: Validate Binary Search Tree","date":"August 17, 2019","description":"dfs, in-order traversal, bst"}}},"pageContext":{"slug":"/leetcode98/","previous":{"fields":{"slug":"/leetcodecpp/"},"frontmatter":{"title":"Leetcode C++ solutions"}},"next":{"fields":{"slug":"/leetcode106/"},"frontmatter":{"title":"leetcode 105 & 106: Construct Binary Tree from Preorder, Postorder and Inorder Traversal"}}}}}