{"componentChunkName":"component---src-templates-blog-post-js","path":"/blogs/leetcode05/","result":{"data":{"site":{"siteMetadata":{"title":"Chenxiao's Blog","author":"Chenxiao Guan"}},"markdownRemark":{"id":"ac83da20-215d-5464-8cde-f83d09b2d4a7","excerpt":"与之前做的上一题一样，此题也是一道难度为medium的题，个人认为比上一题要稍微难一些。\n我们还是先来一起看一下题目描述：  Solution 1: Brute Force Solution 看到这道题最先想到的当然就是暴力解法。遍历字符串中每一个字符，对每一个字符测试包含此字符的substring…","html":"<p>与之前做的上一题一样，此题也是一道难度为medium的题，个人认为比上一题要稍微难一些。\n我们还是先来一起看一下题目描述：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/68d8b7248e8e7477dcd20f0dbcfec811/8cdda/%E6%8F%8F%E8%BF%B0.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.86486486486486%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABcklEQVQ4y62SWUsDMRSF8/9/mA+C4IMIgra1s3TWbLNnMj3emy70obYiDXxkIck9OSfCNh2iJMV6vUYcx9hQnyQJ0vSwFkUR9vs9LhvPf0M4k6PP17DWIC8rKG2gjIFUGsZaVLVE2/dw8wzbtBinCbeagHcIUFuWQ5XlCOvy3sM5F/ppcpjp4mVZAmHvceyPcyFJUVZUKEjdLsuR5QWNSyTpLqgrqyqoVUQYS0WvacKaVAq1lIQKe7mw4EU+nBclUYQDmorwBu+Xs4JLTsr8lXWhtEa6y6CNxSOaGMaJwqhh2w5FVUPTcxz75WYKwp/h+XgH3icUKXt6fsHqO8LH5wp5xZf3AUNFDH0rTen2VPgeI4Um+mHENqEApA5KFSnkSzmsslakWobQ+MBAB27BrxCcEqfL/YM8HEPsTdehHwaqQn+NPLzOcgMfUhe2bfH69o6Ykv7abCHJU5bf/cGzS7qTh6yopD9nyPiO/GQf/gun/AOXW/IvypqFBAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"描述\"\n        title=\"描述\"\n        src=\"/static/68d8b7248e8e7477dcd20f0dbcfec811/fcda8/%E6%8F%8F%E8%BF%B0.png\"\n        srcset=\"/static/68d8b7248e8e7477dcd20f0dbcfec811/12f09/%E6%8F%8F%E8%BF%B0.png 148w,\n/static/68d8b7248e8e7477dcd20f0dbcfec811/e4a3f/%E6%8F%8F%E8%BF%B0.png 295w,\n/static/68d8b7248e8e7477dcd20f0dbcfec811/fcda8/%E6%8F%8F%E8%BF%B0.png 590w,\n/static/68d8b7248e8e7477dcd20f0dbcfec811/efc66/%E6%8F%8F%E8%BF%B0.png 885w,\n/static/68d8b7248e8e7477dcd20f0dbcfec811/8cdda/%E6%8F%8F%E8%BF%B0.png 1168w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3>Solution 1: Brute Force Solution</h3>\n<p>看到这道题最先想到的当然就是暴力解法。遍历字符串中每一个字符，对每一个字符测试包含此字符的substring是否为palindrome。这个solution实现起来应该并不难，但是很显然此解法的时间复杂度为O(<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>N</mi><mn>3</mn></msup></mrow><annotation encoding=\"application/x-tex\">N^3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span></span></span>)，并不会是面试官想要的。</p>\n<h3>Solution 2: Dynamic Programming</h3>\n<p>这题其实有一个特别简单的思路来实现recursion的解题。\n我们假设<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">S_{i,j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>为从index i到j的一个substring，那么<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">S_{i,j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>是一个palindromic substring的条件则为：</p>\n<ol>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">S_{i-1,j-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 为palindromic substring</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><msub><mi>S</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_i == S_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span></li>\n</ol>\n<p>不难看出，我们可以建立一个二维的memo来存储<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">S_{ij}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>是否为一个palindromic substring，也就是动态规划。遍历完所有i与j之后，找到j-i最大的那一对i和j数值即可得出最长的substring是哪一个。这个方法的时间复杂度为O(<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">N^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>)，空间复杂度同样为O(<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">N^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>)。</p>\n<h3>Solution 3: Expand Around Center</h3>\n<p>除了dynamic programming之外，还有一种方式可以达到使用constant space就能解题。思路和动态规划相似，为了满足两个条件，我们可以从一个string的中间开始向两侧延伸，如果延伸的两个字符相同，那么我们就继续延伸，依次对每一个字符串中的字符做相同的操作。可以想象的是，因为我们要对每一个字符进行延伸，且延伸动作的最坏情况是延伸整个字符串，所以这个方法的时间复杂度同样为O(<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">N^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>),然而空间复杂度被缩小到了O(1)。\n让我们来看一下这个算法在Go语言中的实现：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> low<span class=\"token punctuation\">,</span> maxlen <span class=\"token builtin\">int</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">longestPalindrome</span><span class=\"token punctuation\">(</span>s <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span>\n    charArray <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token function\">rune</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\n    length <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>charArray<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> length <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> s\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">extendPalindrome</span><span class=\"token punctuation\">(</span>charArray<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">extendPalindrome</span><span class=\"token punctuation\">(</span>charArray<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">string</span><span class=\"token punctuation\">(</span>charArray<span class=\"token punctuation\">[</span>low<span class=\"token punctuation\">:</span>low<span class=\"token operator\">+</span>maxlen<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">extendPalindrome</span><span class=\"token punctuation\">(</span>charArray <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">rune</span><span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> k <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> k <span class=\"token operator\">&lt;</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>charArray<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> charArray<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> charArray<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        j<span class=\"token operator\">--</span>\n        k<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> maxlen <span class=\"token operator\">&lt;</span> k <span class=\"token operator\">-</span> j <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">{</span>\n        low <span class=\"token operator\">=</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n        maxlen <span class=\"token operator\">=</span> k <span class=\"token operator\">-</span> j <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ol>\n<li>首先我们检查边界条件。如果长度小于2的话，我们直接返回原字符串。</li>\n<li>一个for loop来遍历每一个字符。这里注意的是，我们从第二个字符开始一直遍历到倒数第二个字符防止边界溢出。</li>\n<li>一个<code class=\"language-text\">extnendPalindrome</code>函数来延伸我们的子字符串。如果延伸的两个字符相等，我们更新j和k两个index的数值来进行延伸，直到<code class=\"language-text\">s[j]</code>和<code class=\"language-text\">s[k]</code>不相等为止。</li>\n<li>最后，我们根据延伸完后的j和k数值来更新子字符串起始位置，以及最长子字符串的长度。</li>\n<li><code class=\"language-text\">extendPalindrome</code>在loop中被调用了两次，原因在于我们既要考虑奇数长度的字符串，也要考虑偶数长度的。</li>\n</ol>\n<h3>总结</h3>\n<p>这一道题是一道相对简单的动态规划题目。如果能最初能想到递归的解法，那么不难再进一步想到2d 动态规划。因为recursion和动态规划是我的弱项，所以自己做的时候还是用了很久的时间。希望以后再接再厉。</p>","frontmatter":{"title":"Leetcode 5: Longest Palindromic Substring","date":"April 11, 2019","description":"Go语言对于Leetcode第5题的两个解法"}}},"pageContext":{"slug":"/leetcode05/","previous":{"fields":{"slug":"/leetcode24/"},"frontmatter":{"title":"Leetcode 24: Swap Nodes in Pairs"}},"next":{"fields":{"slug":"/leetcode12/"},"frontmatter":{"title":"LeetCode 12 / 13: Integer to Roman & Roman to Integer"}}}}}