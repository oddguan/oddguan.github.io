{"componentChunkName":"component---src-templates-blog-post-js","path":"/blogs/leetcode46/","result":{"data":{"site":{"siteMetadata":{"title":"Chenxiao's Blog","author":"Chenxiao Guan"}},"markdownRemark":{"id":"7ecb8a19-58e5-5048-8529-5c702929ed7b","excerpt":"有好几天没有更新了，因为这两天考完Econ放松了一下再加上身体有点不舒服就没怎么做题。我们先来看一下题目描述：  和之前做过的一道Next Permutation有一点相似（回想起被支配的恐惧）。我这里的第一反应是以为这道题很简单。。采用dfs来进行逐层搜索，将依次的下一个元素push…","html":"<p>有好几天没有更新了，因为这两天考完Econ放松了一下再加上身体有点不舒服就没怎么做题。我们先来看一下题目描述：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 492px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4c637d6b4642506583580560e610c33d/5c6e9/%E6%8F%8F%E8%BF%B0.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 79.05405405405406%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsSAAALEgHS3X78AAABiUlEQVQ4y61Ua0/jMBD0//9zfDghUelIW2jrvOM8HOfZYXYhCHQnHfSwNLK92Z2sZ9c2NknwuD9gT0RRhN3uAdZafGVcr9f3eYMJTQFfWPi2RuVqpFmOruswjKNiWVaEYSBGzPOMifAhYJrmP8hkGAw10MbAyoD1qoHLujJw0WAZwzih9T0JF7V3fa+2vw3Tk8APkxJpZsymZ0DlnO477+G5Hyf6MDPNlrMXOyG+m8/KREzTtiiKEq6uEacpsrzQ/f54xMXGKsGZmsoP5FtZOdoyxEmq32QtyPKc8iwwYjwcn/B8OuMnhpGjuLqhRl6LIEcPnEW/cXotwvhWjH+DGYq4d7/usfsdIS8dj52j5A8C7aLvd2Eko0c58sWqQYgUH9ffgJE02z7ANSwOBfdh+JTdV4k2XzOzcYUoYpZP5wsa9tt/E1bU7GQT2DRj04ZPDjcRlq7BkW1zjhO9ET9AWOPwfFLCTcObizKwDysWxLUdmo5X6cZ2eW8beU2kKeVBmJftUbgNM6/eC/M63CGowXmHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"描述\"\n        title=\"描述\"\n        src=\"/static/4c637d6b4642506583580560e610c33d/5c6e9/%E6%8F%8F%E8%BF%B0.png\"\n        srcset=\"/static/4c637d6b4642506583580560e610c33d/12f09/%E6%8F%8F%E8%BF%B0.png 148w,\n/static/4c637d6b4642506583580560e610c33d/e4a3f/%E6%8F%8F%E8%BF%B0.png 295w,\n/static/4c637d6b4642506583580560e610c33d/5c6e9/%E6%8F%8F%E8%BF%B0.png 492w\"\n        sizes=\"(max-width: 492px) 100vw, 492px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>和之前做过的一道<a href=\"https://oddguan.io/leetcode31/\">Next Permutation</a>有一点相似（回想起被支配的恐惧）。我这里的第一反应是以为这道题很简单。。采用dfs来进行逐层搜索，将依次的下一个元素push到当前数组里，然后将最终答案push到我们的result array中好像就可以了。这个想法显然是不对的：第一，我们当前数组的下一个元素不一定在最后一个元素之后。在给定例子中，<code class=\"language-text\">1,2,3</code>确实是原数组顺序依次push进当前数组的，然而其他数组并非如此。我们需要一种方法来记住我们目前已经使用过（没使用过）的数字都是哪些，然后再将任意一个未使用过的数字push进数组，再进行常规的dfs backtracking即可。我最初想到的记录未使用数字的方法是使用一个<code class=\"language-text\">set</code>，每次push一个数字后就将其踢出<code class=\"language-text\">set</code>，然后进行dfs，return后再将数字重新插回<code class=\"language-text\">set</code>即可。来看一下C++的实现：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> <span class=\"token function\">permute</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> result<span class=\"token punctuation\">;</span>\n        unordered_set<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">unusedNums</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            unusedNums<span class=\"token punctuation\">.</span><span class=\"token function\">erase</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> n<span class=\"token punctuation\">{</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> unusedNums<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            unusedNums<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        \n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span><span class=\"token operator\">&amp;</span> result<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> n<span class=\"token punctuation\">,</span> unordered_set<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> unusedNums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> level<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>level <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            result<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>unusedNums<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> unusedNums<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                n<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                unusedNums<span class=\"token punctuation\">.</span><span class=\"token function\">erase</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> unusedNums<span class=\"token punctuation\">,</span> level <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                unusedNums<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                n<span class=\"token punctuation\">.</span><span class=\"token function\">pop_back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>我们来分析一下时间复杂度。首先给定一个长度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span>的数组，一共有<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi><mo stretchy=\"false\">!</mo></mrow><annotation encoding=\"application/x-tex\">N!</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">!</span></span></span></span>种permutation。我们在获得每一个permutation之前都要进行一段线性搜索来找到当前可以继续搜索的数字是哪一个，所以我们最终的runtime是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>N</mi><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(NN!)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">!</span><span class=\"mclose\">)</span></span></span></span>。提交后时间打败了20%，显然是有很大的提升空间的。</p>\n<p>我们知道既然长度为N的数组有<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi><mo stretchy=\"false\">!</mo></mrow><annotation encoding=\"application/x-tex\">N!</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">!</span></span></span></span>个permutation，那我们时间复杂度的lower bound就一定是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi><mo stretchy=\"false\">!</mo></mrow><annotation encoding=\"application/x-tex\">N!</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">!</span></span></span></span>。那我们优化的角度就可以从线性搜索开始。我们现在的approach是使用一个<code class=\"language-text\">set</code>来记录所有未使用过的数字，每次dfs时进行一个线性搜索来寻找下一个可能的数字是哪一个，最终当level到底时return。如果我们有一个方法来使用当前数组来记录过未使用的元素，是不是就可以不用<code class=\"language-text\">set</code>了呢？</p>\n<p>其实这里的idea很类似于insertion sort。我们假设给定数组的前半部分是已使用的所有数字，后半部分是未使用的数字，而中间的分割我们使用一个int来pass给dfs，这样我们就可以在当前数组内记录所有数字的状态了，我们来看一个小例子：</p>\n<p>假设我们的input是<code class=\"language-text\">1,2,3</code>，我们从<code class=\"language-text\">1</code>开始进行第一层搜索。我们需要一个loop来循环<code class=\"language-text\">nums</code>中<code class=\"language-text\">1</code>之后的包括自己的所有数字，也就是<code class=\"language-text\">1</code>,<code class=\"language-text\">2</code>和<code class=\"language-text\">3</code>。我们将他们依次交换以后再递归dfs交换后的数组即可，level+1。举个例子，当第一层遍历到<code class=\"language-text\">2</code>时，我们先把<code class=\"language-text\">2</code>和<code class=\"language-text\">1</code>交换，使<code class=\"language-text\">2</code>变为第一个元素，然后再递归将<code class=\"language-text\">2</code>之后的<code class=\"language-text\">1</code>和<code class=\"language-text\">3</code>交换，这样就可以得到<code class=\"language-text\">2</code>开头的所有数组了。这个思路不是我自己想出来的，确实是值得学习，也不禁感叹自己的脑子确实是不如别人。。我们来看一下实现：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> <span class=\"token function\">permute</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> result<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span><span class=\"token operator\">&amp;</span> result<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> pos<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pos <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            result<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> pos<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>pos<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">,</span> pos <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>pos<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>代码简洁明了，时间和空间都是快过100%。这个方法的时间复杂度是完完全全比我的方法快了一个线性级别，也就是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N!)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">!</span><span class=\"mclose\">)</span></span></span></span>。我们生成每一个permutation都只访问这个permutation中的元素一次，并每一次访问的时间都是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，所以时间复杂度就是exactly <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N!)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">!</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<h3 id=\"总结\" style=\"position:relative;\"><a href=\"#%E6%80%BB%E7%BB%93\" aria-label=\"总结 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>总结</h3>\n<p>虽然又是一道搜索题目，自己也只想出了一个brute force并没有能优化，但是看答案还是学习到了不少。这一篇就当做是答案赏析吧，希望自己有朝一日也能轻松写出这么简洁又有效的代码。</p>","frontmatter":{"title":"LeetCode 46: Permutations","date":"May 03, 2019","description":"有好几天没有更新了，再来做一道dfs的题目。"}}},"pageContext":{"slug":"/leetcode46/","previous":{"fields":{"slug":"/leetcode33/"},"frontmatter":{"title":"LeetCode 33 & 153: Search in Rotated Sorted Array / Find Minimum in Rotated Sorted Array"}},"next":{"fields":{"slug":"/leetcode55/"},"frontmatter":{"title":"LeetCode 55: Jump Game"}}}}}