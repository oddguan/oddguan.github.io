{"componentChunkName":"component---src-templates-blog-post-js","path":"/blogs/leetcode25/","result":{"data":{"site":{"siteMetadata":{"title":"Chenxiao's Blog","author":"Chenxiao Guan"}},"markdownRemark":{"id":"60c52825-546e-570a-b11f-de0f6cee1453","excerpt":"被一个course project搞的生活不能自理，因此有一段时间没有更新博客了。这道题其实在几天之前我就开始想怎么做了，写了一个方法时间没有跑过，不知道是自己写错了还是算法的思想有问题就去看了看答案，发现自己想的没问题，应该就是写错了。。 我们先来看一下题目描述：  一道经典的reverse linkedlist…","html":"<p>被一个course project搞的生活不能自理，因此有一段时间没有更新博客了。这道题其实在几天之前我就开始想怎么做了，写了一个方法时间没有跑过，不知道是自己写错了还是算法的思想有问题就去看了看答案，发现自己想的没问题，应该就是写错了。。</p>\n<p>我们先来看一下题目描述：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1eea2583bb3cbbc242bf67f0e0f7cae2/f4281/%E6%8F%8F%E8%BF%B0.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 93.24324324324323%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAACMElEQVQ4y6WUiW7jMAxE/f/fuGgOx0fi+5DlMywf6yzaYJuiWAG0ZB3DoThU0DsncZpIHMeSZZkk2odhKHmeS67/cRRJ0zRi7X6Xz+2u/88WuLqVPErkertJer2aRQrKf1lWEiesZbKsq6zbJtM8m/0LzAClH0Uar5vvMoyTzHoQHv3gZdMNOi3Oj+IGb4CdG9ScfNeCeVvFzwqE52ky896rjTIMfh97mx/28aiOsWEYbA/zTh0tyyIBYR2OJzmHF/nzdpBEQ67qWrK8kLwopaxquWW59pUUupcx803bWl+Upa0xP46jBHzarpNKDwIEk/9pAZS59CS9mpf0ejO29BdNThQncoliWw8vkY0xxuxjnj2H01lQTABlFrDjOZS3w1Ezm9oYR4TJHg7hhCjoP0IvrAeUfVXdqGz0Mh/3Q8+d1rrAHa2a8V+HDCpJgcFP7TvtfdFh3/cWGuwIB6Z972ScZtWfNz1i67p9AX6RlMGk0XW9ASKFWkutU9BWrXNeWr0WqgPQbbu/BLUsIxunGWrbzu4PlrnqEPaDChyGgDfqdJqX14Aov9ODgAJG6LAkg7B+gFFyjfbz8gMg2gHESk5FjgNYO70KK0VlxH0S8qj/1POrBAWwOakGf9NeJoUPekOg1C+iJes8Y/Q8Y4U6RexUx7iX5jOzTZl/PF/aCC/SA+e9nNAkAFZ+Ufy3NJnHKQ8I1QMJ1m5Ztvf5zlDRCT1OUwufp+uZxedwYfNsj/l36KK/RQdTlLIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"描述\"\n        title=\"描述\"\n        src=\"/static/1eea2583bb3cbbc242bf67f0e0f7cae2/fcda8/%E6%8F%8F%E8%BF%B0.png\"\n        srcset=\"/static/1eea2583bb3cbbc242bf67f0e0f7cae2/12f09/%E6%8F%8F%E8%BF%B0.png 148w,\n/static/1eea2583bb3cbbc242bf67f0e0f7cae2/e4a3f/%E6%8F%8F%E8%BF%B0.png 295w,\n/static/1eea2583bb3cbbc242bf67f0e0f7cae2/fcda8/%E6%8F%8F%E8%BF%B0.png 590w,\n/static/1eea2583bb3cbbc242bf67f0e0f7cae2/efc66/%E6%8F%8F%E8%BF%B0.png 885w,\n/static/1eea2583bb3cbbc242bf67f0e0f7cae2/f4281/%E6%8F%8F%E8%BF%B0.png 1016w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>一道经典的reverse linkedlist类型题目。分组来reverse其中一部分的nodes，这道题其实有两种实现方法：iterative和recursive。\niterative的话，我们需要得到linkedlist的长度，然后对每k个节点做reverse即可。这个方法需要two pass，因为我们第一个pass要得到linkedlist的长度，然后再做循环。Runtime是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>2</mn><mi>N</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(2N)=O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>，Space是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。recursive的解法个人感觉相对更好理解一下，我们reverse前k个nodes，然后再recursively reverse剩余的node就可以了。这个方法只需要one pass，虽然Runtime依然是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>，但是显然是比第一个方法要快很多的。Space是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>K</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(K)=O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p>先来看一下C++ iterative的解法：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    ListNode<span class=\"token operator\">*</span> <span class=\"token function\">reverseKGroup</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> head<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>head <span class=\"token operator\">||</span> k <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> head<span class=\"token punctuation\">;</span>\n        ListNode <span class=\"token function\">dummy</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        dummy<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> length <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>head <span class=\"token operator\">=</span> head<span class=\"token operator\">-></span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">++</span>length<span class=\"token punctuation\">;</span>\n        ListNode<span class=\"token operator\">*</span> prev <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>dummy<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> l <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> l <span class=\"token operator\">+</span> k <span class=\"token operator\">&lt;=</span> length<span class=\"token punctuation\">;</span> l <span class=\"token operator\">+=</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            ListNode<span class=\"token operator\">*</span> current <span class=\"token operator\">=</span> prev<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n            ListNode<span class=\"token operator\">*</span> nxt <span class=\"token operator\">=</span> current<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> k<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                current<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> nxt<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n                nxt<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> prev<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n                prev<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> nxt<span class=\"token punctuation\">;</span>\n                nxt <span class=\"token operator\">=</span> current<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            prev <span class=\"token operator\">=</span> current<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> dummy<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>个人认为比较难理解的地方内循环中reverse的地方。我们保留了三个指针分别指向<code class=\"language-text\">prev</code>, <code class=\"language-text\">current</code>和<code class=\"language-text\">nxt</code>。原因在于，我们reverse完k个节点以后需要知道我们目前的头在哪里，以及头的前一个节点在哪里。需要注意的是，<code class=\"language-text\">prev</code>和<code class=\"language-text\">current</code>这两个指针在内循环中是不变的。我们来举一个例子：</p>\n<p>假如我们的input是一个这样的链表：1->2->3->4->5。假设k=3，那么我们最终的结果就应该是3->2->1->4->5。</p>\n<p>我们首先需要一个dummy node来保存我们的输出头，所以dummy->next初始指向1，并作为我们最初的<code class=\"language-text\">prev</code>。我们最初的<code class=\"language-text\">current</code>为1，<code class=\"language-text\">nxt</code>为2。</p>\n<p>在内循环的第一次循环中，我们想要达到的目标是调换1和2，使链表变为d->2->1->3->4->5。因此我们在第12行先将<code class=\"language-text\">current-&gt;next</code>指向<code class=\"language-text\">nxt-&gt;next</code>，也就是将1的next指向3。然后我们将<code class=\"language-text\">nxt-&gt;next</code>指向<code class=\"language-text\">prev-&gt;next</code>。这里需要注意的是，<code class=\"language-text\">prev-&gt;next</code>是不一定等于<code class=\"language-text\">current</code>的，因为我们<code class=\"language-text\">prev</code>指针永远指向<code class=\"language-text\">dummy</code>，这样才能保留我们最终reverse结束后的头部。可以这样理解：我们的最终目标是使<code class=\"language-text\">dummy-&gt;next</code>指向3，如果同时移动<code class=\"language-text\">prev</code>的话，就是pair-wise的reverse了，因此<code class=\"language-text\">prev</code>在一次小循环中是不应该变的。同样的，<code class=\"language-text\">current</code>在最初指向1，其实到最后我们做完reverse之后，<code class=\"language-text\">current</code>还是应该指向1，也就是长度为k的小链表的最后一个节点。唯一改变的是<code class=\"language-text\">nxt</code>，因为我们需要一直保存<code class=\"language-text\">current</code>的下一个节点。</p>\n<p>想明白以后我们提交答案：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9084cbd95596a4b8e2c08590d54c3399/f4281/iterative.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.810810810810814%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA+klEQVQoz51QCW6EMBDL/x9YVauKLrCU5SghByEXuDNZPrAdycrhmZFtscUIRsgZKSXsPiDnA+d5vg0uMe8OD6shg0dMGVLbcv6neKlwzsFtDsYYjOOERUoYu0Ebi2VVWJVC99OjfXTl31KvVBpKm3JK4le6796/FPa0pBtGtDRU1S2GacbzAjdFisNai40WJYqF4/AhFDDP4HvOL1cihEhDqeSXyGog0pISQwrZQlly0BIadPtecNCbkS8uX/lzrxjmX/TDVJR1zxHfdYPbV4WPzxuYY9uSUDctqnuNhqxzHJpUs2Xm50UWKPoXnEkZukg+WQXnxQ3v1h/7Bh9tt/QfsAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"iterative\"\n        title=\"iterative\"\n        src=\"/static/9084cbd95596a4b8e2c08590d54c3399/fcda8/iterative.png\"\n        srcset=\"/static/9084cbd95596a4b8e2c08590d54c3399/12f09/iterative.png 148w,\n/static/9084cbd95596a4b8e2c08590d54c3399/e4a3f/iterative.png 295w,\n/static/9084cbd95596a4b8e2c08590d54c3399/fcda8/iterative.png 590w,\n/static/9084cbd95596a4b8e2c08590d54c3399/efc66/iterative.png 885w,\n/static/9084cbd95596a4b8e2c08590d54c3399/f4281/iterative.png 1016w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>和预想之中差不多，虽然memory方面打败了100%，但是时间上并不是最优化的，只打败了17%。和之前提到的一样，因为这个算法需要two passes，所以时间上还是慢了一些。那么我们再来看一下recursive的解法：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    ListNode<span class=\"token operator\">*</span> <span class=\"token function\">reverseKGroup</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> head<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>head <span class=\"token operator\">||</span> k <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> head<span class=\"token punctuation\">;</span>\n        ListNode<span class=\"token operator\">*</span> current <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> l <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">bool</span> hasLengthK <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            current <span class=\"token operator\">=</span> current<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token operator\">++</span>l<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">==</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                hasLengthK <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>hasLengthK<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> head<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            ListNode <span class=\"token function\">dummy</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            dummy<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n            ListNode<span class=\"token operator\">*</span> prev <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>dummy<span class=\"token punctuation\">;</span>\n            ListNode<span class=\"token operator\">*</span> nxt <span class=\"token operator\">=</span> head<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> k<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                head<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> nxt<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n                nxt<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> prev<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n                prev<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> nxt<span class=\"token punctuation\">;</span>\n                nxt <span class=\"token operator\">=</span> head<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            head<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> <span class=\"token function\">reverseKGroup</span><span class=\"token punctuation\">(</span>nxt<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> dummy<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>reverse一段linkedlist的逻辑是和iterative solution一样的。我们第一步先check长度够不够k，如果不够的话直接return head即可；如果够的话，我们对k个node进行reverse，并recursively reverse之后的nodes。</p>\n<p>提交以后的runtime和space如下：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/15c127cbb87289e00e7047ef85b590cb/f4281/recursive.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.810810810810814%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA+0lEQVQoz5VR2Y7DIBDj/79xN2maNHcg9wFJ3DHKHqq6D2vJGvAMAx5UOU9Ihh5mXbBuFrrrsVkL4jxPvAP1V37patkdJmex7js2aTgv608jiU505xys8K8LfkPVjUHdaORFiSCM8EgzFHWDUqhNizTLEdwifAYhKtGGcULb96i1QSP5Ss5y3Yqz/TigdNt6oSIl2Y8jjCTJQwregforv19Im/ayRHbSqCgrZHnhZ8kRTPPsHVBjbt02Px5GkjXzsvi1euQlwjhBnIq1e4LwHiOS/UdwQyaHaY82GzrwYzAY5QKyG0bJD9Bt58k6tfMz5CWkvSItuOuT/osnfJsfNIbzsMMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"recursive\"\n        title=\"recursive\"\n        src=\"/static/15c127cbb87289e00e7047ef85b590cb/fcda8/recursive.png\"\n        srcset=\"/static/15c127cbb87289e00e7047ef85b590cb/12f09/recursive.png 148w,\n/static/15c127cbb87289e00e7047ef85b590cb/e4a3f/recursive.png 295w,\n/static/15c127cbb87289e00e7047ef85b590cb/fcda8/recursive.png 590w,\n/static/15c127cbb87289e00e7047ef85b590cb/efc66/recursive.png 885w,\n/static/15c127cbb87289e00e7047ef85b590cb/f4281/recursive.png 1016w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>无敌！收工。</p>","frontmatter":{"title":"LeetCode 25: Reverse Nodes in k-Group","date":"April 22, 2019","description":"一道看似简单实际暗藏玄机的Hard leetcode题目。"}}},"pageContext":{"slug":"/leetcode25/","previous":{"fields":{"slug":"/leetcode23/"},"frontmatter":{"title":"LeetCode 23: Merge k Sorted Lists"}},"next":{"fields":{"slug":"/leetcode31/"},"frontmatter":{"title":"LeetCode 31: Next Permutation"}}}}}