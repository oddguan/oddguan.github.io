{"componentChunkName":"component---src-templates-blog-post-js","path":"/leetcode24/","result":{"data":{"site":{"siteMetadata":{"title":"Chenxiao's Blog","author":"Chenxiao Guan"}},"markdownRemark":{"id":"6cf56f5f-4e49-5349-ba08-1874015c4115","excerpt":"这是一道leetcode中等难度的题目。题目描述如下：  这题虽然标的是medium，其实思路非常的简单，不过实现起来稍微有一点tricky。\n对每两个节点进行pair-wise交换，只需要建立一个temp pointer\n指向第三个node，交换前两个，再从第三个node…","html":"<p>这是一道leetcode中等难度的题目。题目描述如下：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/oddguan.io/static/7c9e5076168fd44dbb0bc3d3a76a7696/d56e1/%E6%8F%8F%E8%BF%B0.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50.67567567567568%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABO0lEQVQoz61S7W6DMAzM+z/k1I61fCYhQEIIBPds1qpV1V+bpVN8tnHMxcr0jn6uFZ3OZzoDl8uFiqKgsrzSJ9v3/SNUNCX56otG11PdarJ9T8YCONd1pWHyNALsu3GiMEdu+dLk2RTlRAJYzvvbJFvOiGfx13V7a8A8P9WoYZow1QA4TGbJuUGmZLCvtSFre8kfcSfcDcgZQyml1wk50XYdlVUtqJsGXFNVH2fTdkArNYwOF3CO41zLvMclXDtBGsWjbttGy7IIIpDSKj7fLj5OwZIkdq9lP8Yo34QQhCsu9CAs+n+Y0sbS6bsQTf5ij7VZ8EsaGvTDSBpit9qSdSPxfjbQ5R5j3hk8Cj+UPU7mHQbiVYroM0MSlX53zc/zA1ww+UCj9zRBDvYlFw4w55oA/TgeWVus1IJeN3i7Cb3WlyqYAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"题目描述\"\n        title=\"题目描述\"\n        src=\"/oddguan.io/static/7c9e5076168fd44dbb0bc3d3a76a7696/fcda8/%E6%8F%8F%E8%BF%B0.png\"\n        srcset=\"/oddguan.io/static/7c9e5076168fd44dbb0bc3d3a76a7696/12f09/%E6%8F%8F%E8%BF%B0.png 148w,\n/oddguan.io/static/7c9e5076168fd44dbb0bc3d3a76a7696/e4a3f/%E6%8F%8F%E8%BF%B0.png 295w,\n/oddguan.io/static/7c9e5076168fd44dbb0bc3d3a76a7696/fcda8/%E6%8F%8F%E8%BF%B0.png 590w,\n/oddguan.io/static/7c9e5076168fd44dbb0bc3d3a76a7696/efc66/%E6%8F%8F%E8%BF%B0.png 885w,\n/oddguan.io/static/7c9e5076168fd44dbb0bc3d3a76a7696/d56e1/%E6%8F%8F%E8%BF%B0.png 1130w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>这题虽然标的是medium，其实思路非常的简单，不过实现起来稍微有一点tricky。\n对每两个节点进行pair-wise交换，只需要建立一个temp pointer\n指向第三个node，交换前两个，再从第三个node开始即可。</p>\n<p>此题很显然可以使用iterative与recursive两种方法来解题。</p>\n<h3>Iterative</h3>\n<p>先来看一下iterative的做法：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">swapPairs</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">*</span>ListNode<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>ListNode <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> head <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token operator\">||</span> head<span class=\"token punctuation\">.</span>Next <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> head\n    <span class=\"token punctuation\">}</span>\n    dummy <span class=\"token operator\">:=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token punctuation\">)</span>\n    previous <span class=\"token operator\">:=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token punctuation\">)</span>\n    dummy <span class=\"token operator\">=</span> previous\n    previous<span class=\"token punctuation\">.</span>Next <span class=\"token operator\">=</span> head\n    <span class=\"token keyword\">for</span> previous<span class=\"token punctuation\">.</span>Next <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token operator\">&amp;&amp;</span> previous<span class=\"token punctuation\">.</span>Next<span class=\"token punctuation\">.</span>Next <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        a <span class=\"token operator\">:=</span> previous<span class=\"token punctuation\">.</span>Next\n        b <span class=\"token operator\">:=</span> a<span class=\"token punctuation\">.</span>Next\n        previous<span class=\"token punctuation\">.</span>Next<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">.</span>Next<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">.</span>Next <span class=\"token operator\">=</span> b<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">.</span>Next\n        previous <span class=\"token operator\">=</span> a\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> dummy<span class=\"token punctuation\">.</span>Next\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>看上去很简单的逻辑其实暗藏很多玄机。</p>\n<ol>\n<li>首先在第2行check最明显的两个边界条件： <code class=\"language-text\">head</code>和<code class=\"language-text\">head.Next</code>是否为<code class=\"language-text\">nil</code>。</li>\n<li>建立一个<code class=\"language-text\">dummy</code> node来保存原始的<code class=\"language-text\">head</code> pointer。</li>\n<li>这里再建立一个<code class=\"language-text\">previous</code> node来保存上一次交换后的第二个node。原因在于，交换两个node之后\n需要更新之前一次交换后第二个node的<code class=\"language-text\">Next</code> pointer。</li>\n<li>这里最需要注意的是第12行。这里用到了Go语言类似于Python swap values的一个功能来直接同时\n改变三个变量的values。如果这一行有困难理解的话，\n一个比较有用的Stack Overflow回答可以在<a href=\"https://stackoverflow.com/questions/35707222/swap-two-numbers-golang\">这里</a>找到。</li>\n</ol>\n<p>这题的runtime complexity为O(N)。</p>\n<h3>Recursive</h3>\n<p>看完iterative解法以后，我们再来看一下recursive的解法。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">swapPairs</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">*</span>ListNode<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>ListNode <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> head <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token operator\">||</span> head<span class=\"token punctuation\">.</span>Next <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> head\n    <span class=\"token punctuation\">}</span>\n    first<span class=\"token punctuation\">,</span> second<span class=\"token punctuation\">,</span> third <span class=\"token operator\">:=</span> head<span class=\"token punctuation\">,</span> head<span class=\"token punctuation\">.</span>Next<span class=\"token punctuation\">,</span> head<span class=\"token punctuation\">.</span>Next<span class=\"token punctuation\">.</span>Next\n    second<span class=\"token punctuation\">.</span>Next <span class=\"token operator\">=</span> first\n    first<span class=\"token punctuation\">.</span>Next <span class=\"token operator\">=</span> <span class=\"token function\">swapPairs</span><span class=\"token punctuation\">(</span>third<span class=\"token punctuation\">)</span>\n    \n    <span class=\"token keyword\">return</span> second<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>使用递归的解法看上去就简单易懂了很多。</p>\n<ol>\n<li>首先第一步还是check边界条件</li>\n<li>初始化三个node分别代表需要调换的两个node，以及调换之后的下一个node(list)。调换前两个node之后，recursively调换第三个node(list)。</li>\n</ol>\n<p>与iterative一样，runtime complexity为O(N)。然而对于所有的recursion解法都需要有一定的space complexity，大小与递归树成正比。因此，此解法的space complexity一样为O(N)。</p>\n<h2>总结</h2>\n<p>总体来说这一道题难度还是中等偏下，但是我在做的时候花了很久才把iterative solution的调换部分搞明白。对于使用python和go的同学来说，有swap values的功能对于linkedlist类型的题还是比较好用的。使用C++，Java等语言的话，写起来可能会相对吃力一些。</p>","frontmatter":{"title":"Leetcode 24: Swap Nodes in Pairs","date":"April 10, 2019","description":"Go语言对于Leetcode第24题的两个解法"}}},"pageContext":{"slug":"/leetcode24/","previous":{"fields":{"slug":"/javascript02/"},"frontmatter":{"title":"JavaScript从零开始02 | Types"}},"next":{"fields":{"slug":"/leetcode05/"},"frontmatter":{"title":"Leetcode 5: Longest Palindromic Substring"}}}}}